diff --git a/webrender/src/device/gfx/buffer.rs b/webrender/src/device/gfx/buffer.rs
index 95849b20..01a2fcd1 100644
--- a/webrender/src/device/gfx/buffer.rs
+++ b/webrender/src/device/gfx/buffer.rs
@@ -5,12 +5,14 @@
 use hal;
 use hal::Device as BackendDevice;
 use rendy_memory::{Block, Heaps, MemoryBlock, MemoryUsageValue, Write};
+use smallvec::SmallVec;
 
 use std::cell::Cell;
 use std::mem;
 
-pub const MAX_INSTANCE_COUNT: usize = 8192;
-pub const TEXTURE_CACHE_SIZE: usize = 128 << 20; // 128MB
+pub const INSTANCE_BUFFER_SIZE: usize = 1 << 20; // 1MB
+pub const DOWNLOAD_BUFFER_SIZE: usize = 10 << 20; // 10MB
+pub const TEXTURE_CACHE_SIZE: usize = 16 << 20; // 16MB
 
 pub(super) struct Buffer<B: hal::Backend> {
     pub(super) memory_block: MemoryBlock<B>,
@@ -75,7 +77,7 @@ impl<B: hal::Backend> Buffer<B> {
         non_coherent_atom_size_mask: u64,
     ) {
         let size = (data.len() * std::mem::size_of::<T>()) as u64;
-        let range = 0 .. ((size + non_coherent_atom_size_mask) & !non_coherent_atom_size_mask);
+        let range = 0 .. ((size + non_coherent_atom_size_mask) & !non_coherent_atom_size_mask).min(self.buffer_size as u64);
         unsafe {
             let mut mapped = self
                 .memory_block
@@ -223,6 +225,7 @@ pub(super) struct InstancePoolBuffer<B: hal::Backend> {
     pub(super) buffer: Buffer<B>,
     pub(super) offset: usize,
     pub(super) last_update_size: usize,
+    pub(super) last_data_stride: usize,
     non_coherent_atom_size_mask: usize,
 }
 
@@ -231,7 +234,6 @@ impl<B: hal::Backend> InstancePoolBuffer<B> {
         device: &B::Device,
         heaps: &mut Heaps<B>,
         buffer_usage: hal::buffer::Usage,
-        data_stride: usize,
         alignment_mask: usize,
         non_coherent_atom_size_mask: usize,
     ) -> Self {
@@ -241,24 +243,26 @@ impl<B: hal::Backend> InstancePoolBuffer<B> {
             MemoryUsageValue::Dynamic,
             buffer_usage,
             alignment_mask,
-            MAX_INSTANCE_COUNT,
-            data_stride,
+            INSTANCE_BUFFER_SIZE,
+            mem::size_of::<u8>(),
         );
         InstancePoolBuffer {
             buffer,
             offset: 0,
             last_update_size: 0,
+            last_data_stride: 0,
             non_coherent_atom_size_mask,
         }
     }
 
-    fn update<T: Copy>(&mut self, device: &B::Device, data: &[T]) {
+    fn update(&mut self, device: &B::Device, data: &[u8], last_data_stride: usize) {
         self.buffer.update(
             device,
             data,
             self.offset,
             self.non_coherent_atom_size_mask as u64,
         );
+        self.last_data_stride = last_data_stride;
         self.last_update_size = data.len();
         self.offset += self.last_update_size;
     }
@@ -268,93 +272,120 @@ impl<B: hal::Backend> InstancePoolBuffer<B> {
         self.last_update_size = 0;
     }
 
-    fn deinit(self, device: &B::Device, heaps: &mut Heaps<B>) {
+    pub(super) fn deinit(self, device: &B::Device, heaps: &mut Heaps<B>) {
         self.buffer.deinit(device, heaps);
     }
+
+    fn free(&self) -> usize {
+        self.buffer.buffer_size - self.offset
+    }
+
+    fn can_store_data(&self, stride: usize) -> bool {
+        if self.offset_aligned_to(stride) {
+            self.free() >= stride
+        } else {
+            let offset = self.offset + (stride - (self.offset % stride));
+            if offset > self.buffer.buffer_size {
+                false
+            } else {
+                self.buffer.buffer_size - offset >= stride
+            }
+        }
+    }
+
+    fn offset_aligned_to(&self, stride: usize) -> bool {
+        self.offset % stride == 0
+    }
+
+    fn align_offset_to(&mut self, stride: usize) {
+        if !self.offset_aligned_to(stride) {
+            self.offset += stride - (self.offset % stride);
+        }
+    }
 }
 
 pub(super) struct InstanceBufferHandler<B: hal::Backend> {
     pub(super) buffers: Vec<InstancePoolBuffer<B>>,
-    data_stride: usize,
     alignment_mask: usize,
     non_coherent_atom_size_mask: usize,
-    pub(super) current_buffer_index: usize,
+    pub(super) next_buffer_index: usize,
 }
 
 impl<B: hal::Backend> InstanceBufferHandler<B> {
     pub(super) fn new(
-        device: &B::Device,
-        heaps: &mut Heaps<B>,
-        data_stride: usize,
         non_coherent_atom_size_mask: usize,
         alignment_mask: usize,
     ) -> Self {
-        let buffers = vec![InstancePoolBuffer::new(
-            device,
-            heaps,
-            hal::buffer::Usage::VERTEX,
-            data_stride,
-            alignment_mask,
-            non_coherent_atom_size_mask,
-        )];
-
         InstanceBufferHandler {
-            buffers,
-            data_stride,
+            buffers: Vec::new(),
             alignment_mask,
             non_coherent_atom_size_mask,
-            current_buffer_index: 0,
+            next_buffer_index: 0,
         }
     }
 
     pub(super) fn add<T: Copy>(
         &mut self,
         device: &B::Device,
-        mut data: &[T],
+        mut instance_data: &[T],
         heaps: &mut Heaps<B>,
-    ) {
-        assert_eq!(self.data_stride, mem::size_of::<T>());
-        while !data.is_empty() {
-            if self.current_buffer().buffer.buffer_size
-                == self.current_buffer().offset * self.data_stride
-            {
-                self.current_buffer_index += 1;
-                if self.buffers.len() <= self.current_buffer_index {
-                    self.buffers.push(InstancePoolBuffer::new(
+        free_buffers: &mut SmallVec<[InstancePoolBuffer<B>; 16]>,
+    ) -> std::ops::Range<usize> {
+        fn instance_data_to_u8_slice<T: Copy>(data: &[T]) -> &[u8] {
+            unsafe {
+                std::slice::from_raw_parts(
+                    data.as_ptr() as *const u8,
+                    data.len() * mem::size_of::<T>(),
+                )
+            }
+        }
+
+        let data_stride = mem::size_of::<T>();
+        let mut range = 0..0;
+        let mut first_iteration = true;
+        while !instance_data.is_empty() {
+            let need_new_buffer = self.buffers.is_empty()
+                || !self.current_buffer().can_store_data(data_stride);
+            if need_new_buffer {
+                let buffer = match free_buffers.pop() {
+                    Some(b) => b,
+                    None => InstancePoolBuffer::new(
                         device,
                         heaps,
                         hal::buffer::Usage::VERTEX,
-                        self.data_stride,
                         self.alignment_mask,
                         self.non_coherent_atom_size_mask,
-                    ))
-                }
-            }
-
-            let update_size = if (self.current_buffer().offset + data.len()) * self.data_stride
-                > self.current_buffer().buffer.buffer_size
-            {
-                self.current_buffer().buffer.buffer_size / self.data_stride
-                    - self.current_buffer().offset
+                    ),
+                };
+                self.buffers.push(buffer);
+                self.next_buffer_index += 1;
             } else {
-                data.len()
-            };
-
-            self.buffers[self.current_buffer_index].update(device, &data[0 .. update_size]);
-
-            data = &data[update_size ..]
+                self.buffers[self.next_buffer_index - 1].align_offset_to(data_stride);
+            }
+            if first_iteration {
+                range.start = self.next_buffer_index - 1;
+                first_iteration = false;
+            }
+            let update_size = (self.current_buffer().free() / data_stride).min(instance_data.len());
+            self.buffers[self.next_buffer_index - 1].update(device, instance_data_to_u8_slice(&instance_data[0 .. update_size]), data_stride);
+            instance_data = &instance_data[update_size ..];
         }
+        range.end = self.next_buffer_index;
+        range
     }
 
     fn current_buffer(&self) -> &InstancePoolBuffer<B> {
-        &self.buffers[self.current_buffer_index]
+        &self.buffers[self.next_buffer_index - 1]
     }
 
-    pub(super) fn reset(&mut self) {
-        for buffer in &mut self.buffers {
+    pub(super) fn reset(&mut self, free_buffers: &mut SmallVec<[InstancePoolBuffer<B>; 16]>) {
+        // Keep one buffer and move the others back to the free set pool.
+        while self.buffers.len() > 1 {
+            let mut buffer = self.buffers.pop().unwrap();
             buffer.reset();
+            free_buffers.push(buffer);
         }
-        self.current_buffer_index = 0;
+        self.next_buffer_index = self.buffers.len();
     }
 
     pub(super) fn deinit(self, device: &B::Device, heaps: &mut Heaps<B>) {
@@ -494,3 +525,4 @@ impl<B: hal::Backend> UniformBufferHandler<B> {
         }
     }
 }
+
diff --git a/webrender/src/device/gfx/device.rs b/webrender/src/device/gfx/device.rs
index 8318e7ed..9e38f95d 100644
--- a/webrender/src/device/gfx/device.rs
+++ b/webrender/src/device/gfx/device.rs
@@ -35,6 +35,7 @@ use super::program::{Program, PUSH_CONSTANT_BLOCK_SIZE};
 use super::render_pass::*;
 use super::{PipelineRequirements, PrimitiveType, TextureId};
 use super::{LESS_EQUAL_TEST, LESS_EQUAL_WRITE};
+use super::vertex_types;
 
 use super::super::Capabilities;
 use super::super::{ShaderKind, ExternalTexture, GpuFrameId, TextureSlot, TextureFilter};
@@ -70,6 +71,27 @@ pub enum BackendApiType {
     Metal,
 }
 
+const QUAD: [vertex_types::Vertex; 6] = [
+    vertex_types::Vertex {
+        aPosition: [0.0, 0.0, 0.0],
+    },
+    vertex_types::Vertex {
+        aPosition: [1.0, 0.0, 0.0],
+    },
+    vertex_types::Vertex {
+        aPosition: [0.0, 1.0, 0.0],
+    },
+    vertex_types::Vertex {
+        aPosition: [0.0, 1.0, 0.0],
+    },
+    vertex_types::Vertex {
+        aPosition: [1.0, 0.0, 0.0],
+    },
+    vertex_types::Vertex {
+        aPosition: [1.0, 1.0, 0.0],
+    },
+];
+
 pub struct DeviceInit<B: hal::Backend> {
     pub instance: Box<hal::Instance<Backend = B>>,
     pub adapter: hal::Adapter<B>,
@@ -184,6 +206,11 @@ pub struct Device<B: hal::Backend> {
     depth_available: bool,
     upload_method: UploadMethod,
     locals_buffer: UniformBufferHandler<B>,
+    quad_buffer: VertexBufferHandler<B>,
+    instance_buffers: SmallVec<[InstanceBufferHandler<B>; 1]>,
+    free_instance_buffers: SmallVec<[InstancePoolBuffer<B>; 16]>,
+    download_buffer: Option<Buffer<B>>,
+    instance_range: std::ops::Range<usize>,
 
     // HW or API capabilities
     capabilities: Capabilities,
@@ -426,6 +453,7 @@ impl<B: hal::Backend> Device<B> {
         let mut frame_fence = SmallVec::new();
         let mut command_pool = SmallVec::new();
         let mut staging_buffer_pool = SmallVec::new();
+        let mut instance_buffers = SmallVec::new();
         for _ in 0 .. frame_count {
             let fence = device.create_fence(false).expect("create_fence failed");
             frame_fence.push(Fence {
@@ -452,6 +480,10 @@ impl<B: hal::Backend> Device<B> {
                 (limits.optimal_buffer_copy_pitch_alignment - 1) as usize,
                 (limits.optimal_buffer_copy_offset_alignment - 1) as usize,
             ));
+            instance_buffers.push(InstanceBufferHandler::new(
+                (limits.non_coherent_atom_size - 1) as usize,
+                (limits.optimal_buffer_copy_pitch_alignment - 1) as usize,
+            ));
         }
 
         let locals_buffer = UniformBufferHandler::new(
@@ -461,6 +493,16 @@ impl<B: hal::Backend> Device<B> {
             (limits.non_coherent_atom_size - 1) as usize,
         );
 
+        let quad_buffer = VertexBufferHandler::new(
+            &device,
+            &mut heaps,
+            hal::buffer::Usage::VERTEX,
+            &QUAD,
+            mem::size_of::<vertex_types::Vertex>(),
+            (limits.optimal_buffer_copy_pitch_alignment - 1) as usize,
+            (limits.non_coherent_atom_size - 1) as usize,
+        );
+
         let mut per_group_descriptor_sets = FastHashMap::default();
         let descriptor_data:
             FastHashMap<DescriptorGroup, DescriptorGroupData<B>>
@@ -654,6 +696,11 @@ impl<B: hal::Backend> Device<B> {
             save_cache,
 
             locals_buffer,
+            quad_buffer,
+            instance_buffers,
+            free_instance_buffers: SmallVec::new(),
+            download_buffer: None,
+            instance_range: 0..0,
             wait_for_resize: false,
 
             use_push_consts,
@@ -1275,6 +1322,7 @@ impl<B: hal::Backend> Device<B> {
         }
         self.staging_buffer_pool[self.next_id].reset();
         self.reset_program_buffer_offsets();
+        self.instance_buffers[self.next_id].reset(&mut self.free_instance_buffers);
         self.delete_retained_textures();
     }
 
@@ -1288,10 +1336,9 @@ impl<B: hal::Backend> Device<B> {
 
     fn reset_program_buffer_offsets(&mut self) {
         for program in self.programs.values_mut() {
-            program.instance_buffer[self.next_id].reset();
             if let Some(ref mut index_buffer) = program.index_buffer {
                 index_buffer[self.next_id].reset();
-                program.vertex_buffer[self.next_id].reset();
+                program.vertex_buffer.as_mut().unwrap()[self.next_id].reset();
             }
         }
     }
@@ -1533,18 +1580,14 @@ impl<B: hal::Backend> Device<B> {
             .expect("Program not found.");
 
         if program.shader_kind.is_debug() {
-            program.vertex_buffer[self.next_id].update(&self.device, vertices, &mut self.heaps);
+            program.vertex_buffer.as_mut().unwrap()[self.next_id].update(&self.device, vertices, &mut self.heaps);
         } else {
             warn!("This function is for debug shaders only!");
         }
     }
 
     fn update_instances<T: Copy>(&mut self, instances: &[T]) {
-        assert_ne!(self.bound_program, INVALID_PROGRAM_ID);
-        self.programs
-            .get_mut(&self.bound_program)
-            .expect("Program not found.")
-            .bind_instances(&self.device, &mut self.heaps, instances, self.next_id);
+        self.instance_range = self.instance_buffers[self.next_id].add(&self.device, instances, &mut self.heaps, &mut self.free_instance_buffers);
     }
 
     fn draw(&mut self) {
@@ -1657,6 +1700,9 @@ impl<B: hal::Backend> Device<B> {
                 self.next_id,
                 self.descriptor_data.pipeline_layout(&descriptor_group),
                 self.use_push_consts,
+                &self.quad_buffer,
+                &self.instance_buffers[self.next_id],
+                self.instance_range.clone(),
             );
 
         if depth_test_changed {
@@ -2688,16 +2734,19 @@ impl<B: hal::Backend> Device<B> {
             (false, 1)
         };
 
-        let mut download_buffer: Buffer<B> = Buffer::new(
-            &self.device,
-            &mut self.heaps,
-            MemoryUsageValue::Download,
-            hal::buffer::Usage::TRANSFER_DST,
-            (self.limits.optimal_buffer_copy_pitch_alignment - 1) as usize,
-            output.len(),
-            stride,
-        );
-
+        assert!(output.len() <= DOWNLOAD_BUFFER_SIZE, "output len {:?} buffer size {:?}", output.len(), DOWNLOAD_BUFFER_SIZE);
+        if self.download_buffer.is_none() {
+            self.download_buffer = Some(Buffer::new(
+                &self.device,
+                &mut self.heaps,
+                MemoryUsageValue::Download,
+                hal::buffer::Usage::TRANSFER_DST,
+                (self.limits.optimal_buffer_copy_pitch_alignment - 1) as usize,
+                DOWNLOAD_BUFFER_SIZE / stride,
+                stride,
+            ));
+        }
+        let download_buffer = self.download_buffer.as_mut().unwrap();
         let mut command_pool = unsafe {
             self.device.create_command_pool_typed(
                 &self.queue_group,
@@ -2836,7 +2885,6 @@ impl<B: hal::Backend> Device<B> {
             output.swap_with_slice(&mut data);
         }
 
-        download_buffer.deinit(&self.device, &mut self.heaps);
         unsafe {
             command_pool.reset();
             self.device.destroy_command_pool(command_pool.into_raw());
@@ -3567,6 +3615,16 @@ impl<B: hal::Backend> Device<B> {
             for mut staging_buffer_pool in self.staging_buffer_pool {
                 staging_buffer_pool.deinit(&self.device, &mut self.heaps);
             }
+            self.quad_buffer.deinit(&self.device, &mut self.heaps);
+            for mut instance_buffer in self.instance_buffers {
+                instance_buffer.deinit(&self.device, &mut self.heaps);
+            }
+            for buffer in self.free_instance_buffers {
+                buffer.deinit(&self.device, &mut self.heaps);
+            }
+            if let Some(buffer) = self.download_buffer {
+                buffer.deinit(&self.device, &mut self.heaps);
+            }
             for image in self.frame_images {
                 image.deinit(&self.device, &mut self.heaps);
             }
diff --git a/webrender/src/device/gfx/program.rs b/webrender/src/device/gfx/program.rs
index f4c95740..8d9d6a1c 100644
--- a/webrender/src/device/gfx/program.rs
+++ b/webrender/src/device/gfx/program.rs
@@ -34,33 +34,12 @@ const SPECIALIZATION_FEATURES: &'static [&'static str] = &[
     "DITHERING",
     "DEBUG_OVERDRAW",
 ];
-const QUAD: [vertex_types::Vertex; 6] = [
-    vertex_types::Vertex {
-        aPosition: [0.0, 0.0, 0.0],
-    },
-    vertex_types::Vertex {
-        aPosition: [1.0, 0.0, 0.0],
-    },
-    vertex_types::Vertex {
-        aPosition: [0.0, 1.0, 0.0],
-    },
-    vertex_types::Vertex {
-        aPosition: [0.0, 1.0, 0.0],
-    },
-    vertex_types::Vertex {
-        aPosition: [1.0, 0.0, 0.0],
-    },
-    vertex_types::Vertex {
-        aPosition: [1.0, 1.0, 0.0],
-    },
-];
 
 
 pub(crate) struct Program<B: hal::Backend> {
     pipelines: FastHashMap<(hal::pso::BlendState, hal::pso::DepthTest), B::GraphicsPipeline>,
-    pub(super) vertex_buffer: SmallVec<[VertexBufferHandler<B>; 1]>,
+    pub(super) vertex_buffer: Option<SmallVec<[VertexBufferHandler<B>; 1]>>,
     pub(super) index_buffer: Option<SmallVec<[VertexBufferHandler<B>; 1]>>,
-    pub(super) instance_buffer: SmallVec<[InstanceBufferHandler<B>; 1]>,
     pub(super) shader_name: String,
     pub(super) shader_kind: ShaderKind,
     pub(super) constants: [u32; PUSH_CONSTANT_BLOCK_SIZE],
@@ -316,57 +295,23 @@ impl<B: hal::Backend> Program<B> {
             ShaderKind::DebugFont => mem::size_of::<vertex_types::DebugFontVertex>(),
             _ => mem::size_of::<vertex_types::Vertex>(),
         };
-
-        let instance_buffer_stride = match shader_kind {
-            ShaderKind::Primitive
-            | ShaderKind::Brush
-            | ShaderKind::Text
-            | ShaderKind::Cache(VertexArrayKind::Primitive) => {
-                mem::size_of::<vertex_types::PrimitiveInstanceData>()
-            }
-            ShaderKind::ClipCache | ShaderKind::Cache(VertexArrayKind::Clip) => {
-                mem::size_of::<vertex_types::ClipMaskInstance>()
-            }
-            ShaderKind::Cache(VertexArrayKind::Blur) => {
-                mem::size_of::<vertex_types::BlurInstance>()
-            }
-            ShaderKind::Cache(VertexArrayKind::Border) => {
-                mem::size_of::<vertex_types::BorderInstance>()
-            }
-            ShaderKind::Cache(VertexArrayKind::Scale) => {
-                mem::size_of::<vertex_types::ScalingInstance>()
-            }
-            ShaderKind::Cache(VertexArrayKind::LineDecoration) => {
-                mem::size_of::<vertex_types::LineDecorationInstance>()
-            }
-            sk if sk.is_debug() => 1,
-            _ => unreachable!(),
-        };
-
-        let mut vertex_buffer = SmallVec::new();
-        let mut instance_buffer = SmallVec::new();
-        let mut index_buffer = if shader_kind.is_debug() {
-            Some(SmallVec::new())
+        let (mut vertex_buffer, mut index_buffer) = if shader_kind.is_debug() {
+            (Some(SmallVec::new()), Some(SmallVec::new()))
         } else {
-            None
+            (None, None)
         };
         for _ in 0 .. frame_count {
-            vertex_buffer.push(VertexBufferHandler::new(
-                device,
-                heaps,
-                hal::buffer::Usage::VERTEX,
-                &QUAD,
-                vertex_buffer_stride,
-                (limits.optimal_buffer_copy_pitch_alignment - 1) as usize,
-                (limits.non_coherent_atom_size - 1) as usize,
-            ));
-            instance_buffer.push(InstanceBufferHandler::new(
-                device,
-                heaps,
-                instance_buffer_stride,
-                (limits.non_coherent_atom_size - 1) as usize,
-                (limits.optimal_buffer_copy_pitch_alignment - 1) as usize,
-            ));
+            if let Some(ref mut vertex_buffer) = vertex_buffer {
+                vertex_buffer.push(VertexBufferHandler::new(
+                    device,
+                    heaps,
+                    hal::buffer::Usage::VERTEX,
+                    &[0],
+                    vertex_buffer_stride,
+                    (limits.optimal_buffer_copy_pitch_alignment - 1) as usize,
+                    (limits.non_coherent_atom_size - 1) as usize,
+                ));
+            }
             if let Some(ref mut index_buffer) = index_buffer {
                 index_buffer.push(VertexBufferHandler::new(
                     device,
@@ -384,24 +329,12 @@ impl<B: hal::Backend> Program<B> {
             pipelines,
             vertex_buffer,
             index_buffer,
-            instance_buffer,
             shader_name: String::from(shader_name),
             shader_kind,
             constants: [0; PUSH_CONSTANT_BLOCK_SIZE],
         }
     }
 
-    pub(super) fn bind_instances<T: Copy>(
-        &mut self,
-        device: &B::Device,
-        heaps: &mut Heaps<B>,
-        instances: &[T],
-        buffer_id: usize,
-    ) {
-        assert!(!instances.is_empty());
-        self.instance_buffer[buffer_id].add(device, instances, heaps);
-    }
-
     pub(super) fn submit(
         &mut self,
         cmd_buffer: &mut hal::command::CommandBuffer<B, hal::Graphics>,
@@ -420,9 +353,14 @@ impl<B: hal::Backend> Program<B> {
         next_id: usize,
         pipeline_layout: &B::PipelineLayout,
         use_push_consts: bool,
+        vertex_buffer: &VertexBufferHandler<B>,
+        instance_buffer: &InstanceBufferHandler<B>,
+        instance_range: std::ops::Range<usize>,
     ) {
-        let vertex_buffer = &self.vertex_buffer[next_id];
-        let instance_buffer = &self.instance_buffer[next_id];
+        let vertex_buffer = match &self.vertex_buffer {
+            Some(ref vb) => vb.get(next_id).unwrap(),
+            None => vertex_buffer
+        };
         unsafe {
             if use_push_consts {
                 cmd_buffer.push_graphics_constants(
@@ -496,7 +434,7 @@ impl<B: hal::Backend> Program<B> {
                     );
                 }
             } else {
-                for i in 0 ..= instance_buffer.current_buffer_index {
+                for i in instance_range.into_iter() {
                     cmd_buffer.bind_vertex_buffers(
                         0,
                         Some((&vertex_buffer.buffer().buffer, 0))
@@ -511,11 +449,12 @@ impl<B: hal::Backend> Program<B> {
                             viewport.rect,
                             clear_values,
                         );
-                        let offset = instance_buffer.buffers[i].offset;
-                        let size = instance_buffer.buffers[i].last_update_size;
+                        let data_stride = instance_buffer.buffers[i].last_data_stride;
+                        let end = instance_buffer.buffers[i].offset / data_stride;
+                        let start = end - instance_buffer.buffers[i].last_update_size / data_stride;
                         encoder.draw(
                             0 .. vertex_buffer.buffer_len as _,
-                            (offset - size) as u32 .. offset as u32,
+                            start as u32 .. end as u32,
                         );
                     }
                 }
@@ -524,17 +463,16 @@ impl<B: hal::Backend> Program<B> {
     }
 
     pub(super) fn deinit(mut self, device: &B::Device, heaps: &mut Heaps<B>) {
-        for mut vertex_buffer in self.vertex_buffer {
-            vertex_buffer.deinit(device, heaps);
+        if let Some(vertex_buffer) = self.vertex_buffer {
+            for mut vertex_buffer in vertex_buffer {
+                vertex_buffer.deinit(device, heaps);
+            }
         }
         if let Some(index_buffer) = self.index_buffer {
             for mut index_buffer in index_buffer {
                 index_buffer.deinit(device, heaps);
             }
         }
-        for mut instance_buffer in self.instance_buffer {
-            instance_buffer.deinit(device, heaps);
-        }
         for pipeline in self.pipelines.drain() {
             unsafe { device.destroy_graphics_pipeline(pipeline.1) };
         }
